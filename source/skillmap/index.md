title: 技能树
date: 2016-08-16 17:16:13
---

## 区块链黑暗森林自救手册
在线查看：<https://darkhandbook.io/>
github: https://github.com/slowmist/Blockchain-dark-forest-selfguard-handbook
## 知道创宇研发技能表

在线查看：<https://blog.knownsec.com/Knownsec_RD_Checklist/index.html>

##  iOS开发工程师必备技能图谱

iOS开发工程师必备技能图谱：[点击查看大图](/assets/iOS开发工程师必备技能图谱.png)

思维导图下载：[iOS开发工程师必备技能图谱.mindnode](/assets/iOS开发工程师必备技能图谱.zip)

## 软件工程师的任务清单（PSP2.1）

1. Planning（计划）
	1. Estimate（估计这个任务需要多少时间） 
2. Development（开发）
	1. Analysis（分析需求）
	2. Design Spec（生成设计文档）
	3. Design Review（设计复审——和同事审核设计文档）
	4. Coding Standard（代码规范——为目前的开发制定合适的规范）
	5. Design（具体设计）
	6. Coding（具体编码）
	7. Code Review（代码复审）
	8. Test（测试——包括自测，修改代码，提交修改）
3. Record Time Spent（记录用时）
4. Test Report（测试报告）
5. Size Measurement（计算工作量）
6. Postmortem（事后总结）
7. Process Improvement Plan（提出过程改进计划）

## 软件工程师能力自我评价表

转载自：<http://www.cnblogs.com/xinz/p/3852177.html>

这是《构建之法》的一部分，用于工程师自我评价。

人的能力和成长路径都是有多种选择，没有一定之规。 但是很多人喜欢数量化，所以下面的每项回答都可以换算为一个分数，以满足部分读者的需求：

1. 保持高标准，不要受制于破窗理论(broken windows theory)。
当你看到不靠谱的设计、糟糕的代码、过时的文档和测试用例的时候，不要想 “既然别人的代码已经这样了，我的代码也可以随便一点啦。”

    a) 从来没听说过；   
    b) 我就是这样随便过来的；  
    c) 如果有明确要求，我可以做好。  
    d) 一直主动这样做     
    e) 不但主动做， 还会影响同事一起做好

2. 主动解决问题。当看到不靠谱的设计，糟糕的代码的时候，不要想“可能别人会来管这个事情” ，或者“我下个月发一个邮件让大家讨论一下”。要主动地把问题给解决了。

   a) 不懂啥是靠谱的设计；   
   b) 随便应付一下即可；  
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

3. 经常给自己充电，身体训练是运动员生活的一部分，学习是软件工程师职业的伴侣。每半年就要了解和学习一些新的相关技术。通过定期分享（面对面的分享，写技术博客等）来确保自己真正掌握了新技术。

   a) 从来不看书；   
   b) 看了就忘；  
   c) 有时分享。  
   d) 一直主动这样做     
   e) 不但主动做，还会影响同事一起做好

 4. DRY （Don't Repeat Yourself）——别重复。在一个系统中，每一个知识点都应该有一个无异议的、正规的表现形式。

   a) 从来没听说过；   
   b) 听说过，但是认为意思不大；  
   c) 这要讲场合。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

5. 消除不相关模块之间的影响，在设计模块的时候，要让它们目标明确并单一，能独立存在，没有不明确的外部依赖。

   a) 从来没听说过；   
   b) 出了问题再说吧；  
   c) 想做，但是不知道怎么衡量效果。  
   d) 能够在多种语言和架构中做到     
   e) 不但主动做， 还会影响同事一起做好
 
6. 通过快速原型来学习，快速原型的目的是学习，它的价值不在于代码，而在于你通过快速原型学到了什么。

   a) 从来没听说过；   
   b) 把原型直接用于产品，不然就浪费了；  
   c) 不用原型，一直在产品中直接改。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

7. 设计要接近问题领域，在设计的时候，要接近你目标用户的语言和环境。

   a) 从来没听说过；   
   b) 按我的想法设计，用户以后会适应的；  
   c) 大概同意，但是怎么接近用户呢？  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

8. 估计任务所花费的时间，避免意外。在开始工作的时候，要做出时间和潜在影响的估计，并通告相关人士，避免最后关头意外发生。工作中要告知可能的时间变化，事后要总结。

   a) 做完了，就知道花费了，不用事先估计；   
   b) 大概估一下，不必在意时间   
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做    
   e) 不但主动做， 还会影响同事一起做好

9. 图形界面的工具有它的长处，但是不要忘了命令行工具也可以发挥很高的效率，特别是可以用脚本构建各种组合命令的时候。

   a) 一直用鼠标和GUI；   
   b) 到时候问牛人；  
   c) 正在学习命令行工具。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

10. 有很多代码编辑器，请把其中一个用得非常熟练。让编辑器可以实现自己的定制，可以用脚本驱动，用起来得心应手。

   a) 只用老师教的一个；   
   b) 随意；  
   c) 没有任何定制。  
   d) 会定制，并且分享给其他人     
   e) 还会学习和使用各种编辑器的扩展。

11. 理解常用的设计模式，并知道择机而用。设计模式不错，更重要的是知道它的目的是什么，什么时候用，什么时候不用。

   a) 从来没听说过；   
   b) 模式没用；  
   c) 每写100行程序，我就尽量用一个模式。  
   d)有实际使用的经验     
   e) 能用具体代码说明模式的利弊

12. 代码版本管理工具是你代码的保障，重要的代码一定要有代码版本管理。

   a) 从来没听说过；   
   b) 用QQ，u盘即可；  
   c) 领导要求才用。  
   d) 经常用     
   e) 不但主动做， 还会影响同事一起做好

13. 在debug的时候，不要惊慌，想想导致问题的原因可能在哪里。一步一步地找到原因。要在实践中运用工具，善于分析日志（log），从中找到bug。同时，在自己的代码里面加 log.

   a) 从来没听说过；   
   b) 只会printf；  
   c) 加log 太麻烦，我的代码不会有bug 的。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

14. 重要的接口要用形式化的“合同”来规定。用文档和断言、自动化测试等工具来保证代码的确按照合同来做事，不多也不少。使用断言 (assertion) 或者其他技术来验证代码中的假设，你认为不可能发生的事情在现实世界中往往会发生。

   a) 从来没听说过；   
   b) 太麻烦，不用；  
   c) 想用，但没有时间。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

15. 只在异常的情况下才使用异常 (Exception),  不加判断地过多使用异常，会降低代码的效率和可维护性。记住不要用异常来传递正常的信息。

   a) 从来没听说过；   
   b) 抓住所有异常  
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

16. 善始善终。如果某个函数申请了空间或其他资源，这个函数负责释放这些资源。

   a) 从来没听说过；   
   b) 随缘；  
   c) 有时这样做。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

17. 当你的软件有多种技术结合在一起的时候，要采用松耦合的配置模式，而不是要把所有代码都混到一起。

   a) 从来没听说过；   
   b) 没有实践的机会；  
   c) 代码都在一起比较好管理。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

18. 把常用模块的功能打造成独立的服务，通过良好的界面 (API) 来调用不同的服务。

   a) 从来没听说过；   
   b) 拷贝代码过来用也可以  
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

19. 在设计中考虑对并行的支持，这样你的API 设计会比较容易扩展。

   a) 从来没听说过；   
   b) 并行不会出错的；  
   c) 任何代码都应支持并行。  
   d) 考虑在适当的层次支持并行     
   e) 不但主动做， 还会影响同事一起做好

20. 在设计中把展现模块 (View) 和实体模块 (Model) 分开，这样你的设计会更有灵活性。 

   a) 代码都在一起比较好改；   
   b) 随缘啦；  
   c) 没搞清楚啥是V，啥是M。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

21. 重视算法的效率，在开始写之前就要估计好算法的效率是哪一个数量级上的（big-O）。

   a) 从来没听说过；   
   b) 我的数据量不大，无所谓；  
   c) 不会有效率问题的，现在CPU 都快了。  
   d) 主动测试程序效率，以验证估算     
   e) 不但主动做， 还会影响同事一起做好

22. 在实际的运行场景中测试你的算法，不要停留在数学分析层面。有时候一个小小的实际因素 (是否支持大小写敏感的排序，数据是否支持多语言)会导致算法效率的巨大变化。

   a) 从来没听说过；   
   b) 想用，但不知道工具  
   c) 主要靠肉眼观察算法效率。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

23. 经常重构代码，同时注意要解决问题的根源。

   a) 从来没听说过；   
   b) 任何修改都可以叫重构；  
   c) 每天应该重构两次。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

24. 在开始设计的时候就要考虑如何测试 ，如果代码出了问题，有log 来辅助debug 么? 尽早测试，经常测试，争取实现自动化测试，争取每一个构建的版本都能有某些自动测试。

   a) 从来没听说过；   
   b) 我的代码不会出问题的；  
   c) 项目没有安排时间，我也没有提这事。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

25. 代码生成工具可以生成一堆一堆的代码，在正式使用它们之前，要确保你能理解它们，并且必要的时候能debug 这些代码。

   a) 从来没听说过；   
   b) 从来不看那些代码；  
   c) 那些代码没有bug。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

26. 和一个实际的用户一起使用软件，获得第一手反馈。 

   a) 从来没听说过；   
   b) 用户太蠢，不值得听反馈；  
   c) 想做但是没有机会。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

27. 在自动测试的时候，要有意引地入bug，来保证自动测试的确能捕获这些错误。

   a) 没听说过；   
   b) 不必这么麻烦；   
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

28. 如果测试没有做完，那么开发也没有做完。

   a) 从来没听说过；   
   b) 签入代码，就是做完了；  
   c) 。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

29. 适当地追求代码覆盖率：每一行的代码都覆盖了，但是程序未必正确。要确保程序覆盖了不同的程序状态和各种组合条件。

   a) 从来没听说过；   
   b) 覆盖20% 就好了；  
   c) 要覆盖至少60%。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

30. 如果团队成员碰到了一个有普遍意义的bug,  应该建立一个测试用例抓住以后将会出现的类似的bug。

   a) 从来没听说过；   
   b) 每个bug都是特殊的；  
   c) 测试用例不值得加  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

31. 测试：多走一步，多考虑一层。如果程序运行了一星期不退出，如果用户的屏幕分辨率再提高一个档次，这个程序会出什么可能的错误?

   a) 从来没听说过；   
   b) 如果有问题，用户会报告的，我们不用测这些；  
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

32. （带领团队）了解用户的期望值，稍稍超出用户的期望值，让用户有惊喜。

    a) 从来没听说过；   
    b) 我们决定用户的期望；  
    c) 如果有明确要求，我可以做好。  
    d) 一直主动这样做     
    e) 不但主动做， 还会影响同事一起做好

33. （带领团队） 不要停留在被动地收集需求，要挖掘需求。真正的需求可能被过时的假设、对用户的误解或其他因素所遮挡。

   a) 从来没听说过；   
   b) 用户不说的，我们不做；  
   c) 如果有明确要求，我可以做好。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

34. （带领团队）把所有的术语和项目相关的名词、缩写等都放在一个地方。

   a) 从来没听说过；   
   b) 都记在我脑子里；  
   c) 大家看代码就好  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

35. （带领团队）不要依赖于某个人的手动操作，而是要把这些操作都做成有相关权限的人士都能运行的脚本。这样就不会出现因为某人休假而项目被卡住的情况。

   a) 从来没听说过；   
   b) 我们没有休假的，没关系；  
   c) 出了问题再说  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

36. （带领团队）要让重用变得更容易。一个软件团队要创造一种环境，让大家有轻松的心态来尝试各种想法 （例如，模块的重用，效能的提升，等）。

   a) 都听领导的；   
   b) 团队严肃紧张最好；  
   c) 不必尝试，失败的可能性太大。  
   d) 一直主动这样做     
   e) 不但主动做， 还会影响同事一起做好

37. （带领团队）在每一次迭代之后，都要总结经验，让下一次迭代的进度安排更可靠，质量更高。

    a) 没有时间总结，直接做下一版；   
    b) 总结用处不大；  
    c) 如果上级有要求，就做一下；  
    d) 一直主动这样做     
    e) 不但主动做， 还会影响同事一起做好

## 代码复审的核查表

1. 概要部分
	1. 代码符合需求和规格说明么？
	2. 代码设计是否考虑周全？
	3. 代码可读性如何？
	4. 代码容易维护么？
	5. 代码的每一行都执行并检查过了吗？

2. 设计规范部分
	1. 设计是否遵从已知的设计模式或项目中常用的模式？
	2. 有没有硬编码或字符串/数字等存在？
	3. 代码有没有依赖于某一平台，是否会影响将来的移植（如Win32到Win64）？
	4. 开发者新写的代码是否用已有的Library/SDK/Framework中的功能实现？在本项目中是否存在类似的功能可以调用而不用全部重新实现？
	5. 有没有无用的代码可以清除？（很多人想保留尽可能多的代码，因为以后可能会用上，这样导致程序文件中有很多注释掉的代码，这些代码都可以删除，因为源代码控制已经保存了原来的老代码。）

3. 代码规范部分
	1. 修改的部分符合代码标准和风格么（详细条文略）？

4. 具体代码部分
	1. 有没有对错误进行处理？对于调用的外部函数，是否检查了返回值或处理了异常？
	2. 参数传递有无错误，字符串的长度是字节的长度还是字符（可能是单/双字节）的长度，是以0开始计数还是以1开始计数？
	3. 边界条件是如何处理的？switch 语句的 default 分支是如何处理的？循环有没有可能出现死循环？
	4. 有没有使用断言（Assert）来保证我们认为不变的条件真的得到满足？
	5. 对资源的利用，是在哪里申请，在哪里释放的？有无可能存在资源泄漏（内存、文件、各种GUI资源、数据库访问的连接，等等）？有没有优化的空间？
	6. 数据结构中有没有用不到的元素？

5. 效能
	1. 代码的效能（Performance）如何？最坏的情况是怎样的？
	2. 代码中，特别是循环中是否有明显可优化的部分（C++ 中反复创建类，C# 中 string 的操作是否能用StringBuilder来优化）？
	3. 对于系统和网络的调用是否会超时？如何处理？

6. 可读性
	代码可读性如何？有没有足够的注释？
	
7. 可测试性
	代码是否需要更新或创建新的单元测试？
	
针对特性领域的开发（如数据库、网页、多线程等），可以整理专门的核查表。 


